        -:    0:Source:../src/config.c
        -:    0:Graph:config_test.gcno
        -:    0:Data:config_test.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * config.c
        -:    3: * --------
        -:    4: * Configuration management implementation
        -:    5: *
        -:    6: * Table-driven configuration with validation
        -:    7: */
        -:    8:
        -:    9:#include "config.h"
        -:   10:#include <stdio.h>
        -:   11:#include <stdlib.h>
        -:   12:#include <string.h>
        -:   13:#include <ctype.h>
        -:   14:#include <limits.h>
        -:   15:#include <errno.h>
        -:   16:#include <syslog.h>
        -:   17:
        -:   18:/* Static configuration instance */
        -:   19:static config_t g_config;
        -:   20:
        -:   21:/* Configuration parameter descriptor for table-driven parsing */
        -:   22:typedef struct {
        -:   23:    const char *key;
        -:   24:    enum { TYPE_INT, TYPE_STRING } type;
        -:   25:    size_t offset;          /* Offset within config_t */
        -:   26:    int min_value;          /* For TYPE_INT only */
        -:   27:    int max_value;          /* For TYPE_INT only */
        -:   28:    size_t max_length;      /* For TYPE_STRING only */
        -:   29:    bool validate_path;     /* For TYPE_STRING: check for path traversal */
        -:   30:} config_param_t;
        -:   31:
        -:   32:/* Forward declarations */
        -:   33:static void trim(char *s);
        -:   34:static int validate_path_component(const char *path);
        -:   35:
        -:   36:/* Table-driven configuration parameters */
        -:   37:static const config_param_t config_params[] = {
        -:   38:    {
        -:   39:        .key = "brightness",
        -:   40:        .type = TYPE_INT,
        -:   41:        .offset = offsetof(config_t, brightness),
        -:   42:        .min_value = 0,
        -:   43:        .max_value = CONFIG_MAX_BRIGHTNESS,
        -:   44:    },
        -:   45:    {
        -:   46:        .key = "off_timeout",
        -:   47:        .type = TYPE_INT,
        -:   48:        .offset = offsetof(config_t, off_timeout),
        -:   49:        .min_value = CONFIG_MIN_OFF_TIMEOUT,
        -:   50:        .max_value = CONFIG_MAX_OFF_TIMEOUT,
        -:   51:    },
        -:   52:    {
        -:   53:        .key = "poll_interval",
        -:   54:        .type = TYPE_INT,
        -:   55:        .offset = offsetof(config_t, poll_interval),
        -:   56:        .min_value = CONFIG_MIN_POLL_INTERVAL,
        -:   57:        .max_value = CONFIG_MAX_POLL_INTERVAL,
        -:   58:    },
        -:   59:    {
        -:   60:        .key = "dim_percent",
        -:   61:        .type = TYPE_INT,
        -:   62:        .offset = offsetof(config_t, dim_percent),
        -:   63:        .min_value = CONFIG_MIN_DIM_PERCENT,
        -:   64:        .max_value = CONFIG_MAX_DIM_PERCENT,
        -:   65:    },
        -:   66:    {
        -:   67:        .key = "backlight",
        -:   68:        .type = TYPE_STRING,
        -:   69:        .offset = offsetof(config_t, backlight),
        -:   70:        .max_length = sizeof(((config_t *)0)->backlight),
        -:   71:        .validate_path = true,
        -:   72:    },
        -:   73:    {
        -:   74:        .key = "device",
        -:   75:        .type = TYPE_STRING,
        -:   76:        .offset = offsetof(config_t, device),
        -:   77:        .max_length = sizeof(((config_t *)0)->device),
        -:   78:        .validate_path = true,
        -:   79:    },
        -:   80:};
        -:   81:
        -:   82:static const size_t config_params_count = sizeof(config_params) / sizeof(config_params[0]);
        -:   83:
        -:   84:/*
        -:   85: * Trim whitespace from both ends of string (in-place)
        -:   86: */
      372:   87:static void trim(char *s) {
      372:   88:    if (s == NULL) return;
        -:   89:
        -:   90:    /* Trim leading whitespace */
      372:   91:    char *p = s;
      384:   92:    while (isspace((unsigned char)*p)) p++;
      372:   93:    if (p != s) memmove(s, p, strlen(p) + 1);
        -:   94:
        -:   95:    /* Trim trailing whitespace */
      372:   96:    char *end = s + strlen(s) - 1;
      522:   97:    while (end > s && isspace((unsigned char)*end)) *end-- = '\0';
      372:   98:}
        -:   99:
        -:  100:/*
        -:  101: * Validate path component (CERT FIO32-C)
        -:  102: * Returns 0 if safe, -1 if contains traversal sequences
        -:  103: */
       30:  104:static int validate_path_component(const char *path) {
       30:  105:    if (path == NULL || path[0] == '\0')
    #####:  106:        return -1;
        -:  107:
        -:  108:    /* Reject absolute paths */
       30:  109:    if (path[0] == '/')
        6:  110:        return -1;
        -:  111:
        -:  112:    /* Reject path traversal */
       24:  113:    if (strstr(path, "..") != NULL)
       12:  114:        return -1;
        -:  115:
        -:  116:    /* Reject path separators (should be just a filename) */
       12:  117:    if (strchr(path, '/') != NULL)
    #####:  118:        return -1;
        -:  119:
       12:  120:    return 0;
       30:  121:}
        -:  122:
        -:  123:/*
        -:  124: * Safe string to integer conversion (CERT INT31-C compliant)
        -:  125: */
      138:  126:int config_safe_atoi(const char *str, int *result) {
      138:  127:    if (str == NULL || result == NULL)
    #####:  128:        return -1;
        -:  129:
        -:  130:    char *endptr;
      138:  131:    errno = 0;
      138:  132:    long val = strtol(str, &endptr, 10);
        -:  133:
        -:  134:    /* Check for conversion errors */
      138:  135:    if (endptr == str || *endptr != '\0' || errno == ERANGE)
       24:  136:        return -1;
        -:  137:
        -:  138:    /* Check for overflow */
      114:  139:    if (val < INT_MIN || val > INT_MAX)
    #####:  140:        return -1;
        -:  141:
      114:  142:    *result = (int)val;
      114:  143:    return 0;
      138:  144:}
        -:  145:
        -:  146:/*
        -:  147: * Parse single configuration line using table-driven approach
        -:  148: */
      120:  149:static int parse_config_line(config_t *config, const char *key, const char *value, int line_num) {
        -:  150:    /* Find matching parameter in table */
      348:  151:    for (size_t i = 0; i < config_params_count; i++) {
      348:  152:        const config_param_t *param = &config_params[i];
        -:  153:
      348:  154:        if (strcmp(key, param->key) != 0)
      228:  155:            continue;
        -:  156:
        -:  157:        /* Found matching parameter */
      120:  158:        void *field_ptr = (char *)config + param->offset;
        -:  159:
      120:  160:        if (param->type == TYPE_INT) {
        -:  161:            int tmp;
       90:  162:            if (config_safe_atoi(value, &tmp) != 0) {
    #####:  163:                syslog(LOG_WARNING, "Invalid value for %s: '%s' at line %d",
    #####:  164:                       param->key, value, line_num);
    #####:  165:                return -1;
        -:  166:            }
        -:  167:
        -:  168:            /* Validate range */
       90:  169:            if (tmp < param->min_value || tmp > param->max_value) {
       30:  170:                syslog(LOG_WARNING, "%s=%d out of range (%d-%d) at line %d",
       30:  171:                       param->key, tmp, param->min_value, param->max_value, line_num);
       30:  172:                return -1;
        -:  173:            }
        -:  174:
       60:  175:            *(int *)field_ptr = tmp;
       60:  176:            return 0;
        -:  177:
       30:  178:        } else if (param->type == TYPE_STRING) {
        -:  179:            /* Validate path if required */
       30:  180:            if (param->validate_path && validate_path_component(value) != 0) {
       18:  181:                syslog(LOG_WARNING, "Invalid path for %s: '%s' (no / or ..) at line %d",
       18:  182:                       param->key, value, line_num);
       18:  183:                return -1;
        -:  184:            }
        -:  185:
        -:  186:            /* Copy string with bounds checking */
       12:  187:            snprintf((char *)field_ptr, param->max_length, "%s", value);
       12:  188:            return 0;
        -:  189:        }
    #####:  190:    }
        -:  191:
        -:  192:    /* Unknown parameter */
    #####:  193:    syslog(LOG_WARNING, "Unknown config key '%s' at line %d", key, line_num);
    #####:  194:    return -1;
      120:  195:}
        -:  196:
        -:  197:/*
        -:  198: * Initialize configuration with defaults
        -:  199: */
      126:  200:config_t *config_init(void) {
      126:  201:    g_config.brightness = CONFIG_DEFAULT_BRIGHTNESS;
      126:  202:    g_config.off_timeout = CONFIG_DEFAULT_OFF_TIMEOUT;
      126:  203:    g_config.dim_percent = CONFIG_DEFAULT_DIM_PERCENT;
      126:  204:    g_config.poll_interval = CONFIG_DEFAULT_POLL_INTERVAL;
      126:  205:    g_config.dim_timeout = 0;       /* Calculated later */
      126:  206:    g_config.dim_brightness = 0;    /* Calculated later */
        -:  207:
      126:  208:    snprintf(g_config.backlight, sizeof(g_config.backlight), "%s", CONFIG_DEFAULT_BACKLIGHT);
      126:  209:    snprintf(g_config.device, sizeof(g_config.device), "%s", CONFIG_DEFAULT_DEVICE);
        -:  210:
      126:  211:    return &g_config;
        -:  212:}
        -:  213:
        -:  214:/*
        -:  215: * Load configuration from file
        -:  216: */
       84:  217:int config_load(config_t *config, const char *path) {
       84:  218:    if (config == NULL || path == NULL)
    #####:  219:        return -1;
        -:  220:
       84:  221:    FILE *f = fopen(path, "r");
       84:  222:    if (f == NULL) {
        -:  223:        /* Missing config file is not an error - use defaults */
        6:  224:        return 0;
        -:  225:    }
        -:  226:
        -:  227:    char line[128];
       78:  228:    int line_num = 0;
        -:  229:
      210:  230:    while (fgets(line, sizeof(line), f)) {
      132:  231:        line_num++;
      132:  232:        trim(line);
        -:  233:
        -:  234:        /* Skip comments and empty lines */
      132:  235:        if (line[0] == '#' || line[0] == ';' || line[0] == '\0')
       12:  236:            continue;
        -:  237:
        -:  238:        /* Parse key=value */
        -:  239:        char key[64], value[64];
      120:  240:        if (sscanf(line, "%63[^=]=%63s", key, value) != 2) {
    #####:  241:            syslog(LOG_WARNING, "Malformed config line %d: %s", line_num, line);
    #####:  242:            continue;
        -:  243:        }
        -:  244:
      120:  245:        trim(key);
      120:  246:        trim(value);
        -:  247:
      120:  248:        parse_config_line(config, key, value, line_num);
        -:  249:    }
        -:  250:
       78:  251:    fclose(f);
       78:  252:    return 0;
       84:  253:}
        -:  254:
        -:  255:/*
        -:  256: * Validate and finalize configuration
        -:  257: */
       36:  258:int config_validate(config_t *config, int max_brightness) {
       36:  259:    if (config == NULL)
    #####:  260:        return -1;
        -:  261:
        -:  262:    /* Clamp brightness to hardware maximum */
       36:  263:    if (config->brightness > max_brightness) {
        6:  264:        syslog(LOG_WARNING, "Brightness %d exceeds hardware max %d, clamping",
        6:  265:               config->brightness, max_brightness);
        6:  266:        config->brightness = max_brightness;
        6:  267:    }
        -:  268:
        -:  269:    /* Enforce minimum brightness */
       36:  270:    if (config->brightness < CONFIG_MIN_BRIGHTNESS) {
        6:  271:        syslog(LOG_WARNING, "Brightness %d below minimum %d, using minimum",
        6:  272:               config->brightness, CONFIG_MIN_BRIGHTNESS);
        6:  273:        config->brightness = CONFIG_MIN_BRIGHTNESS;
        6:  274:    }
        -:  275:
        -:  276:    /* Calculate dim_timeout (CERT INT32-C: use long to prevent overflow) */
       36:  277:    long dim_timeout_long = ((long)config->off_timeout * config->dim_percent) / 100;
        -:  278:
       36:  279:    if (dim_timeout_long <= 0 || dim_timeout_long > config->off_timeout) {
    #####:  280:        syslog(LOG_ERR, "Invalid dim_timeout calculation (overflow or config error)");
    #####:  281:        return -1;
        -:  282:    }
        -:  283:
       36:  284:    config->dim_timeout = (int)dim_timeout_long;
        -:  285:
        -:  286:    /* Calculate dim_brightness */
       36:  287:    int calculated_dim = config->brightness / 10;
       36:  288:    config->dim_brightness = (calculated_dim < CONFIG_MIN_DIM_BRIGHTNESS)
       24:  289:                             ? CONFIG_MIN_DIM_BRIGHTNESS : calculated_dim;
        -:  290:
        -:  291:    /* Validate derived values */
       36:  292:    if (config->dim_timeout >= config->off_timeout && config->dim_percent < 100) {
    #####:  293:        syslog(LOG_ERR, "dim_timeout (%d) >= off_timeout (%d)",
    #####:  294:               config->dim_timeout, config->off_timeout);
    #####:  295:        return -1;
        -:  296:    }
        -:  297:
       36:  298:    return 0;
       36:  299:}
