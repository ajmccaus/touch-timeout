        -:    0:Source:test_state.c
        -:    0:Graph:test_state-test_state.gcno
        -:    0:Data:test_state-test_state.gcda
        -:    0:Runs:7
        -:    0:Programs:1
        -:    1:/*
        -:    2: * test_state.c
        -:    3: * ------------
        -:    4: * Unit tests for state machine module
        -:    5: *
        -:    6: * Tests pure logic without hardware dependencies:
        -:    7: * - State initialization
        -:    8: * - Touch event handling
        -:    9: * - Timeout event handling
        -:   10: * - State transitions (FULL -> DIMMED -> OFF)
        -:   11: * - Clock adjustment handling
        -:   12: */
        -:   13:
        -:   14:#include "state.h"
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <unistd.h>
        -:   20:
        -:   21:/* Test framework */
        -:   22:static int tests_run = 0;
        -:   23:static int tests_passed = 0;
        -:   24:static int tests_failed = 0;
        -:   25:
        -:   26:#define TEST(name) static void name(void)
        -:   27:#define RUN_TEST(name) do { \
        -:   28:    printf("  %-60s ", #name); \
        -:   29:    fflush(stdout); \
        -:   30:    tests_run++; \
        -:   31:    name(); \
        -:   32:    tests_passed++; \
        -:   33:    printf("PASS\n"); \
        -:   34:} while(0)
        -:   35:
        -:   36:#define ASSERT_TRUE(cond) do { \
        -:   37:    if (!(cond)) { \
        -:   38:        printf("FAIL\n    %s:%d: %s\n", __FILE__, __LINE__, #cond); \
        -:   39:        tests_failed++; \
        -:   40:        return; \
        -:   41:    } \
        -:   42:} while(0)
        -:   43:
        -:   44:#define ASSERT_EQ(a, b) ASSERT_TRUE((a) == (b))
        -:   45:#define ASSERT_FALSE(cond) ASSERT_TRUE(!(cond))
        -:   46:
        -:   47:/* ==================== INITIALIZATION TESTS ==================== */
        -:   48:
        7:   49:TEST(test_state_init_valid) {
        -:   50:    state_t state;
        7:   51:    int ret = state_init(&state, 100, 10, 150, 300);
        -:   52:
        7:   53:    ASSERT_EQ(ret, 0);
        7:   54:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:   55:    ASSERT_EQ(state.user_brightness, 100);
        7:   56:    ASSERT_EQ(state.dim_brightness, 10);
        7:   57:    ASSERT_EQ(state.dim_timeout_sec, 150);
        7:   58:    ASSERT_EQ(state.off_timeout_sec, 300);
        7:   59:}
        -:   60:
        7:   61:TEST(test_state_init_invalid_null) {
        7:   62:    int ret = state_init(NULL, 100, 10, 150, 300);
        7:   63:    ASSERT_EQ(ret, -1);
        7:   64:}
        -:   65:
        7:   66:TEST(test_state_init_invalid_brightness) {
        -:   67:    state_t state;
        7:   68:    int ret = state_init(&state, 0, 10, 150, 300);
        7:   69:    ASSERT_EQ(ret, -1);
        7:   70:}
        -:   71:
        7:   72:TEST(test_state_init_invalid_timeout) {
        -:   73:    state_t state;
        7:   74:    int ret = state_init(&state, 100, 10, 0, 300);
        7:   75:    ASSERT_EQ(ret, -1);
        7:   76:}
        -:   77:
        7:   78:TEST(test_state_init_invalid_timeout_order) {
        -:   79:    state_t state;
        -:   80:    /* dim_timeout >= off_timeout is invalid */
        7:   81:    int ret = state_init(&state, 100, 10, 300, 300);
        7:   82:    ASSERT_EQ(ret, -1);
        7:   83:}
        -:   84:
        -:   85:/* ==================== TOUCH EVENT TESTS ==================== */
        -:   86:
        7:   87:TEST(test_state_touch_when_full) {
        -:   88:    state_t state;
        7:   89:    state_init(&state, 100, 10, 150, 300);
        -:   90:
        -:   91:    int new_brightness;
        7:   92:    bool changed = state_handle_event(&state, STATE_EVENT_TOUCH, &new_brightness);
        -:   93:
        -:   94:    /* Touch when already FULL should not change brightness */
        7:   95:    ASSERT_FALSE(changed);
        7:   96:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:   97:}
        -:   98:
        7:   99:TEST(test_state_touch_restores_from_dimmed) {
        -:  100:    state_t state;
        7:  101:    state_init(&state, 100, 10, 5, 10);
        -:  102:
        -:  103:    /* Simulate dimming by going back in time */
        7:  104:    state.last_input_time -= 6;
        7:  105:    state.current_state = STATE_DIMMED;
        -:  106:
        -:  107:    int new_brightness;
        7:  108:    bool changed = state_handle_event(&state, STATE_EVENT_TOUCH, &new_brightness);
        -:  109:
        7:  110:    ASSERT_TRUE(changed);
        7:  111:    ASSERT_EQ(new_brightness, 100);
        7:  112:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:  113:}
        -:  114:
        7:  115:TEST(test_state_touch_restores_from_off) {
        -:  116:    state_t state;
        7:  117:    state_init(&state, 100, 10, 5, 10);
        -:  118:
        -:  119:    /* Simulate screen off */
        7:  120:    state.last_input_time -= 15;
        7:  121:    state.current_state = STATE_OFF;
        -:  122:
        -:  123:    int new_brightness;
        7:  124:    bool changed = state_handle_event(&state, STATE_EVENT_TOUCH, &new_brightness);
        -:  125:
        7:  126:    ASSERT_TRUE(changed);
        7:  127:    ASSERT_EQ(new_brightness, 100);
        7:  128:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:  129:}
        -:  130:
        -:  131:/* ==================== TIMEOUT EVENT TESTS ==================== */
        -:  132:
        7:  133:TEST(test_state_timeout_stays_full_when_active) {
        -:  134:    state_t state;
        7:  135:    state_init(&state, 100, 10, 150, 300);
        -:  136:
        -:  137:    /* Just initialized - should stay FULL */
        -:  138:    int new_brightness;
        7:  139:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  140:
        7:  141:    ASSERT_FALSE(changed);
        7:  142:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:  143:}
        -:  144:
        7:  145:TEST(test_state_timeout_dims_after_dim_timeout) {
        -:  146:    state_t state;
        7:  147:    state_init(&state, 100, 10, 5, 10);
        -:  148:
        -:  149:    /* Go back in time to simulate idle period */
        7:  150:    state.last_input_time -= 6;
        -:  151:
        -:  152:    int new_brightness;
        7:  153:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  154:
        7:  155:    ASSERT_TRUE(changed);
        7:  156:    ASSERT_EQ(new_brightness, 10);
        7:  157:    ASSERT_EQ(state.current_state, STATE_DIMMED);
        7:  158:}
        -:  159:
        7:  160:TEST(test_state_timeout_turns_off_after_off_timeout) {
        -:  161:    state_t state;
        7:  162:    state_init(&state, 100, 10, 5, 10);
        -:  163:
        -:  164:    /* Simulate being past off timeout */
        7:  165:    state.last_input_time -= 15;
        -:  166:
        -:  167:    int new_brightness;
        7:  168:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  169:
        7:  170:    ASSERT_TRUE(changed);
        7:  171:    ASSERT_EQ(new_brightness, 0);
        7:  172:    ASSERT_EQ(state.current_state, STATE_OFF);
        7:  173:}
        -:  174:
        7:  175:TEST(test_state_timeout_skips_dim_when_past_off) {
        -:  176:    state_t state;
        7:  177:    state_init(&state, 100, 10, 5, 10);
        -:  178:
        -:  179:    /* Start in FULL, but idle time is past off_timeout */
        7:  180:    state.last_input_time -= 15;
        7:  181:    state.current_state = STATE_FULL;
        -:  182:
        -:  183:    int new_brightness;
        7:  184:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  185:
        -:  186:    /* Should go directly to OFF, skipping DIMMED */
        7:  187:    ASSERT_TRUE(changed);
        7:  188:    ASSERT_EQ(new_brightness, 0);
        7:  189:    ASSERT_EQ(state.current_state, STATE_OFF);
        7:  190:}
        -:  191:
        7:  192:TEST(test_state_timeout_from_dimmed_to_off) {
        -:  193:    state_t state;
        7:  194:    state_init(&state, 100, 10, 5, 10);
        -:  195:
        -:  196:    /* Simulate being dimmed and then waiting for off */
        7:  197:    state.last_input_time -= 15;
        7:  198:    state.current_state = STATE_DIMMED;
        -:  199:
        -:  200:    int new_brightness;
        7:  201:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  202:
        7:  203:    ASSERT_TRUE(changed);
        7:  204:    ASSERT_EQ(new_brightness, 0);
        7:  205:    ASSERT_EQ(state.current_state, STATE_OFF);
        7:  206:}
        -:  207:
        -:  208:/* ==================== CLOCK ADJUSTMENT TESTS ==================== */
        -:  209:
        7:  210:TEST(test_state_handles_clock_backwards) {
        -:  211:    state_t state;
        7:  212:    state_init(&state, 100, 10, 150, 300);
        -:  213:
        -:  214:    /* Simulate clock going backwards (NTP adjustment) */
        7:  215:    state.last_input_time += 100;  /* 100 seconds in future */
        -:  216:
        -:  217:    int new_brightness;
        7:  218:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        -:  219:
        -:  220:    /* Should not change state, just reset timer */
        7:  221:    ASSERT_FALSE(changed);
        7:  222:    ASSERT_EQ(state.current_state, STATE_FULL);
        -:  223:    /* Timer should be reset to approximately now */
        7:  224:    ASSERT_TRUE(state.last_input_time <= time(NULL) + 1);
        7:  225:}
        -:  226:
        -:  227:/* ==================== GETTER TESTS ==================== */
        -:  228:
        7:  229:TEST(test_state_get_current) {
        -:  230:    state_t state;
        7:  231:    state_init(&state, 100, 10, 150, 300);
        -:  232:
        7:  233:    ASSERT_EQ(state_get_current(&state), STATE_FULL);
        -:  234:
        7:  235:    state.current_state = STATE_DIMMED;
        7:  236:    ASSERT_EQ(state_get_current(&state), STATE_DIMMED);
        -:  237:
        7:  238:    state.current_state = STATE_OFF;
        7:  239:    ASSERT_EQ(state_get_current(&state), STATE_OFF);
        7:  240:}
        -:  241:
        7:  242:TEST(test_state_get_brightness) {
        -:  243:    state_t state;
        7:  244:    state_init(&state, 100, 10, 150, 300);
        -:  245:
        7:  246:    state.current_state = STATE_FULL;
        7:  247:    ASSERT_EQ(state_get_brightness(&state), 100);
        -:  248:
        7:  249:    state.current_state = STATE_DIMMED;
        7:  250:    ASSERT_EQ(state_get_brightness(&state), 10);
        -:  251:
        7:  252:    state.current_state = STATE_OFF;
        7:  253:    ASSERT_EQ(state_get_brightness(&state), 0);
        7:  254:}
        -:  255:
        7:  256:TEST(test_state_get_next_timeout_from_full) {
        -:  257:    state_t state;
        7:  258:    state_init(&state, 100, 10, 150, 300);
        -:  259:
        -:  260:    /* Just initialized - should return dim_timeout */
        7:  261:    int timeout = state_get_next_timeout(&state);
        7:  262:    ASSERT_TRUE(timeout > 0);
        7:  263:    ASSERT_TRUE(timeout <= 150);
        7:  264:}
        -:  265:
        7:  266:TEST(test_state_get_next_timeout_from_dimmed) {
        -:  267:    state_t state;
        7:  268:    state_init(&state, 100, 10, 150, 300);
        -:  269:
        -:  270:    /* Simulate being dimmed */
        7:  271:    state.last_input_time -= 160;  /* Past dim, not past off */
        7:  272:    state.current_state = STATE_DIMMED;
        -:  273:
        7:  274:    int timeout = state_get_next_timeout(&state);
        7:  275:    ASSERT_TRUE(timeout > 0);
        -:  276:    /* Allow for timing variance - should be around 140 seconds */
        7:  277:    ASSERT_TRUE(timeout <= 300 - 160 + 1);  /* Allow 1 second variance */
        7:  278:}
        -:  279:
        7:  280:TEST(test_state_get_next_timeout_from_off) {
        -:  281:    state_t state;
        7:  282:    state_init(&state, 100, 10, 150, 300);
        -:  283:
        7:  284:    state.current_state = STATE_OFF;
        -:  285:
        -:  286:    /* No timeout when off - waiting for touch */
        7:  287:    int timeout = state_get_next_timeout(&state);
        7:  288:    ASSERT_EQ(timeout, -1);
        7:  289:}
        -:  290:
        7:  291:TEST(test_state_get_next_timeout_expired) {
        -:  292:    state_t state;
        7:  293:    state_init(&state, 100, 10, 150, 300);
        -:  294:
        -:  295:    /* Simulate being past timeout */
        7:  296:    state.last_input_time -= 400;
        -:  297:
        7:  298:    int timeout = state_get_next_timeout(&state);
        7:  299:    ASSERT_EQ(timeout, 0);  /* Timeout already expired */
        7:  300:}
        -:  301:
        -:  302:/* ==================== STATE TRANSITION SEQUENCE TEST ==================== */
        -:  303:
        7:  304:TEST(test_state_full_sequence) {
        -:  305:    state_t state;
        7:  306:    state_init(&state, 100, 10, 5, 10);
        -:  307:
        -:  308:    /* Verify initial state */
        7:  309:    ASSERT_EQ(state.current_state, STATE_FULL);
        -:  310:
        -:  311:    /* Wait past dim timeout */
        7:  312:    state.last_input_time -= 6;
        -:  313:    int new_brightness;
        7:  314:    bool changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        7:  315:    ASSERT_TRUE(changed);
        7:  316:    ASSERT_EQ(state.current_state, STATE_DIMMED);
        7:  317:    ASSERT_EQ(new_brightness, 10);
        -:  318:
        -:  319:    /* Wait past off timeout */
        7:  320:    state.last_input_time -= 5;  /* Total 11 seconds */
        7:  321:    changed = state_handle_event(&state, STATE_EVENT_TIMEOUT, &new_brightness);
        7:  322:    ASSERT_TRUE(changed);
        7:  323:    ASSERT_EQ(state.current_state, STATE_OFF);
        7:  324:    ASSERT_EQ(new_brightness, 0);
        -:  325:
        -:  326:    /* Touch to restore */
        7:  327:    changed = state_handle_event(&state, STATE_EVENT_TOUCH, &new_brightness);
        7:  328:    ASSERT_TRUE(changed);
        7:  329:    ASSERT_EQ(state.current_state, STATE_FULL);
        7:  330:    ASSERT_EQ(new_brightness, 100);
        7:  331:}
        -:  332:
        -:  333:/* ==================== MAIN TEST RUNNER ==================== */
        -:  334:
        7:  335:int main(void) {
        7:  336:    printf("\n========================================\n");
        7:  337:    printf("State Machine Module Unit Tests\n");
        7:  338:    printf("========================================\n\n");
        -:  339:
        7:  340:    printf("Initialization tests:\n");
        7:  341:    RUN_TEST(test_state_init_valid);
        7:  342:    RUN_TEST(test_state_init_invalid_null);
        7:  343:    RUN_TEST(test_state_init_invalid_brightness);
        7:  344:    RUN_TEST(test_state_init_invalid_timeout);
        7:  345:    RUN_TEST(test_state_init_invalid_timeout_order);
        -:  346:
        7:  347:    printf("\nTouch event tests:\n");
        7:  348:    RUN_TEST(test_state_touch_when_full);
        7:  349:    RUN_TEST(test_state_touch_restores_from_dimmed);
        7:  350:    RUN_TEST(test_state_touch_restores_from_off);
        -:  351:
        7:  352:    printf("\nTimeout event tests:\n");
        7:  353:    RUN_TEST(test_state_timeout_stays_full_when_active);
        7:  354:    RUN_TEST(test_state_timeout_dims_after_dim_timeout);
        7:  355:    RUN_TEST(test_state_timeout_turns_off_after_off_timeout);
        7:  356:    RUN_TEST(test_state_timeout_skips_dim_when_past_off);
        7:  357:    RUN_TEST(test_state_timeout_from_dimmed_to_off);
        -:  358:
        7:  359:    printf("\nClock adjustment tests:\n");
        7:  360:    RUN_TEST(test_state_handles_clock_backwards);
        -:  361:
        7:  362:    printf("\nGetter tests:\n");
        7:  363:    RUN_TEST(test_state_get_current);
        7:  364:    RUN_TEST(test_state_get_brightness);
        7:  365:    RUN_TEST(test_state_get_next_timeout_from_full);
        7:  366:    RUN_TEST(test_state_get_next_timeout_from_dimmed);
        7:  367:    RUN_TEST(test_state_get_next_timeout_from_off);
        7:  368:    RUN_TEST(test_state_get_next_timeout_expired);
        -:  369:
        7:  370:    printf("\nState transition sequence test:\n");
        7:  371:    RUN_TEST(test_state_full_sequence);
        -:  372:
        7:  373:    printf("\n========================================\n");
        7:  374:    printf("Results: %d/%d passed", tests_passed, tests_run);
        7:  375:    if (tests_failed > 0) {
        2:  376:        printf(" (%d FAILED)", tests_failed);
        2:  377:    }
        7:  378:    printf("\n========================================\n\n");
        -:  379:
        7:  380:    return tests_failed > 0 ? 1 : 0;
        -:  381:}
